use crate::deserialise::Error;

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Deserialize, serde::Serialize)]
#[repr(u16)]
pub enum Opcode {
    Copy,
    Load,
    Store,
    Branch,
    CBranch,
    IBranch,
    Call,
    ICall,
    CallOther,
    Return,
    IntEq,
    IntNotEq,
    IntSLess,
    IntSLessEq,
    IntLess,
    IntLessEq,
    IntZExt,
    IntSExt,
    IntNeg,
    IntNot,
    IntAdd,
    IntSub,
    IntMul,
    IntDiv,
    IntSDiv,
    IntRem,
    IntSRem,
    IntCarry,
    IntSCarry,
    IntSBorrow,
    IntAnd,
    IntOr,
    IntXor,
    IntLShift,
    IntRShift,
    IntSRShift,
    BoolNot,
    BoolAnd,
    BoolOr,
    BoolXor,
    FloatEq,
    FloatNotEq,
    FloatLess,
    FloatLessEq,
    FloatIsNaN,
    FloatAdd,
    FloatSub,
    FloatMul,
    FloatDiv,
    FloatNeg,
    FloatAbs,
    FloatSqrt,
    FloatOfInt,
    FloatOfFloat,
    FloatTruncate,
    FloatCeiling,
    FloatFloor,
    FloatRound,
    Build,
    DelaySlot,
    Piece,
    Subpiece,
    Cast,
    Label,
    CrossBuild,
    SegmentOp,
    CPoolRef,
    New,
    Insert,
    Extract,
    PopCount,
    LZCount,
}

impl Opcode {
    pub fn from_str(input: &str) -> Result<Self, Error> {
        Ok(match input {
            "COPY" => Self::Copy,
            "LOAD" => Self::Load,
            "STORE" => Self::Store,
            "BRANCH" => Self::Branch,
            "CBRANCH" => Self::CBranch,
            "BRANCHIND" => Self::IBranch,
            "CALL" => Self::Call,
            "CALLIND" => Self::ICall,
            "CALLOTHER" => Self::CallOther,
            "RETURN" => Self::Return,
            "INT_EQUAL" => Self::IntEq,
            "INT_NOTEQUAL" => Self::IntNotEq,
            "INT_SLESS" => Self::IntSLess,
            "INT_SLESSEQUAL" => Self::IntSLessEq,
            "INT_LESS" => Self::IntLess,
            "INT_LESSEQUAL" => Self::IntLessEq,
            "INT_ZEXT" => Self::IntZExt,
            "INT_SEXT" => Self::IntSExt,
            "INT_ADD" => Self::IntAdd,
            "INT_SUB" => Self::IntSub,
            "INT_CARRY" => Self::IntCarry,
            "INT_SCARRY" => Self::IntSCarry,
            "INT_SBORROW" => Self::IntSBorrow,
            "INT_2COMP" => Self::IntNeg,
            "INT_NEGATE" => Self::IntNot,
            "INT_XOR" => Self::IntXor,
            "INT_AND" => Self::IntAnd,
            "INT_OR" => Self::IntOr,
            "INT_LEFT" => Self::IntLShift,
            "INT_RIGHT" => Self::IntRShift,
            "INT_SRIGHT" => Self::IntSRShift,
            "INT_MULT" => Self::IntMul,
            "INT_DIV" => Self::IntDiv,
            "INT_SDIV" => Self::IntSDiv,
            "INT_REM" => Self::IntRem,
            "INT_SREM" => Self::IntSRem,
            "BOOL_NEGATE" => Self::BoolNot,
            "BOOL_XOR" => Self::BoolXor,
            "BOOL_AND" => Self::BoolAnd,
            "BOOL_OR" => Self::BoolOr,
            "FLOAT_EQUAL" => Self::FloatEq,
            "FLOAT_NOTEQUAL" => Self::FloatNotEq,
            "FLOAT_LESS" => Self::FloatLess,
            "FLOAT_LESSEQUAL" => Self::FloatLessEq,
            "FLOAT_NAN" => Self::FloatIsNaN,
            "FLOAT_ADD" => Self::FloatAdd,
            "FLOAT_DIV" => Self::FloatDiv,
            "FLOAT_MULT" => Self::FloatMul,
            "FLOAT_SUB" => Self::FloatSub,
            "FLOAT_NEG" => Self::FloatNeg,
            "FLOAT_ABS" => Self::FloatAbs,
            "FLOAT_SQRT" => Self::FloatSqrt,
            "INT2FLOAT" => Self::FloatOfInt,
            "FLOAT2FLOAT" => Self::FloatOfFloat,
            "TRUNC" => Self::FloatTruncate,
            "CEIL" => Self::FloatCeiling,
            "FLOOR" => Self::FloatFloor,
            "ROUND" => Self::FloatRound,
            // NOTE: in SLEIGH 4 we see MULTIEQUAL in the "debug" SLA produced by the compiler.
            "BUILD" | "MULTIEQUAL" => Self::Build,
            "DELAY_SLOT" | "INDIRECT" => Self::DelaySlot,
            "PIECE" => Self::Piece,
            "SUBPIECE" => Self::Subpiece,
            "CAST" => Self::Cast,
            "LABEL" | "PTRADD" => Self::Label,
            "CROSSBUILD" | "PTRSUB" => Self::CrossBuild,
            "SEGMENTOP" => Self::SegmentOp,
            "CPOOLREF" => Self::CPoolRef,
            "NEW" => Self::New,
            "INSERT" => Self::Insert,
            "EXTRACT" => Self::Extract,
            "POPCOUNT" => Self::PopCount,
            "LZCOUNT" => Self::LZCount,
            _ => return Err(Error::Invariant("invalid opcode name")),
        })
    }
}
